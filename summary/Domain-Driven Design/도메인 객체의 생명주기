# Domain-Driven Design(도메인 주도 설계)

## 도메인 객체의 생명주기

### **AGGREGATE(집합체)**
---
- AGGREGATE는 데이터 변경의 단위로 다루는 연관객체의 묶음  
- 각 AGGREGATE는 루트(root)와 경계(boundary)를 가진다.  
- 경계는 AGGREGATE에 무엇이 포함되고 포함되지 않는지를 정의
- 루트는 단 하나만 존재하며, AGGREGATE에 포함된 특정 ENTITY를 가리킨다.  
- 경계안의 객체는 서로 참조할 수 있지만, 경계 바깥의 객체는 해당 AGGREGATE의 구성요소 가운데 루트만 참조할 수 있다.
- 루트 이외의 ENTITY는 지역식별성을 지니며, 지역 식별성은 AGGREGATE 내에서만 구분되면 된다.

ENTITY와 VALUE OBJECT를 AGGREGATE로 모으고 각각에 대해 경계를 정의하라. 한 ENTITY를 골라 AGGREGATE의 루트로 만들고 AGGREGATE 경계 내부의 객체에 대해서는 루트를 거쳐 접근할 수 있게 하라. AGGREGATE 밖의 객체는 루트만 참조할 수 있게하라. 내부 구성요소에 대한 일시적인 참조는 단일 연산에서만 사용할 목적에 한해 외부로 전달될 수 있다. 루트를 경유하지 않고는 AGGREGATE의 내부를 변경할 수 없다. 이런 식으로 AGGREGATE의 각 요소를 배치하면 AGGREGATE 안의 객체와 전체로서의 AGGREGATE의 상태를 변경할 때 모든 불변식을 효과적으로 이행할 수 있다.

**결론 : AGGREGATE는 생명주기의 전 단계에서 불변식이 유지돼야 할 범위를 표시**

### **FACTORY(팩토리)**
---
자신의 책임이 다른 객체를 생성하는 것인 프로그램 요소를 FACTORY라 한다.
FACTORY는 복잡한 객체나 AGGREGATE를 생성하는데 필요한 지식을 캡슐화한다. FACTORY는 클라이언트의 목적과 생성된 객체의 추상적인 관점을 반영하는 인터페이스를 제공한다.

그러므로
- 복잡한 객체와 AGGREGATE의 인스턴스를 생성하는 책임을 별도의 객체로 옮겨라. 이 객체 자체는 도메인 모델에서 아무런 책임도 맡지 않을 수도 있지만 여전히 도메인 설계의 일부를 구성한다. 
- 모든 복잡한 객체 조립 과정을 캡슐화하는 동시에 클라이언트가 인스턴스화되는 객체의 구상 클래스를 참조할 필요가 없는 인터페이스를 제공하라. 
- 전체 AGGREGATE를 하나의 단위로 생성해서 그것의 불변식이 이행되게하라.

FACTORY를 설계하는 Pattern : FACTORY METHOD, ABSRACT FACTORY, BUILDER  

### **REPOSITORY(리파지터리)**
---
- 객체를 사용하기 위해 객체를 탐색하기 위한 진입점
- REPOSITORY는 데이터베이스 접근 기술과 전략을 캡슐화 한다.

전역적인 접근이 필요한 각 객체 타입에 대해 메모리상에 해당 타입의 객체로, 구성된 컬렉션이 있다는 착각을 불러 일으키는 객체를 만든다.

AGGREGATE 루트에 대해서만 REPOSITORY를 제공하고, 모든 객체 저장과 접근은 REPOSITORY에 위임해서 클라이언트가 모델에 집중하게 하라.

**REPOSITORY의 이점**
- Repository는 영속화된 객체를 획득하고 해당 객체의 생명주기를 관리하기 위한 단순한 모델을 클라이언트에게 제시한다.
- Repository는 영속화 기술과 다수의 데이터베이스 전략, 또는 심지어 다수의 데이터 소스로부터 애플리케이션과 도메인 설계를 분리해준다.
- Repository는 객체 접근에 관한 설계 결정을 전해준다.
- Repository를 이용하면 테스트에서 사용할 가짜 구현을 손쉽게 대처할 수 있다.

*※ REPOSITORY를 직접 구현하는 것은 어렵다. 하지만 최근의 언어는 REPOSITORY를 구현하는 많은 수단을 제공한다. 예) ORM*